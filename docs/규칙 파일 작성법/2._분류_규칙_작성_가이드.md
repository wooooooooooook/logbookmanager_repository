# 분류 규칙 작성 가이드

이 문서는 규칙 파일의 **계층적 분류 시스템**을 작성하고 이해하는 데 필요한 지침을 제공합니다.

## 1. 계층적 분류 시스템 개요

- **검사종류 (Examination Type)**: 일반촬영, CT, MRI, 초음파, 시술, 핵의학 등
- **세부전공 (Specialty)**: 각 검사종류별로 정의된 전문 분야
- **비고 (Remarks, 옵션)**: 세부전공 하위의 추가 구분 레벨

## 2. 분류 규칙 구조 (`classification_rules`)

각 분류 규칙은 다음 속성을 가집니다:

| 필드명                    | 타입      | 필수/선택 | 기본값   | 설명                                         | 예시                      |
|--------------------------|-----------|-----------|----------|----------------------------------------------|--------------------------|
| `category_id`            | string    | 필수      | -        | 검사종류 식별자                              | `xray`, `ct`, `mri`      |
| `priority`               | number    | 필수      | -        | 규칙의 우선순위 (낮을수록 우선)              | 1, 10, 99                |
| `conditions`             | array     | 필수      | -        | 조건 목록                                    | -                        |
| `logic`                  | string    | 선택      | `AND`    | 조건 평가 방법 (`AND` 또는 `OR`)              | `AND`, `OR`              |
| `composed_by_subcategories` | boolean | 선택      | `false`  | 하위 카테고리로만 구성되는지 여부            | `true`, `false`          |

> ⚠️ **중요:**  
`category_id` 값은 반드시 규칙 파일의 `categories` 섹션에서 정의한 `id`와 **정확히 일치해야 합니다**.  
- `category_id`가 `categories`에 없는 값을 사용하면 분류가 정상적으로 동작하지 않습니다.
- 오타, 대소문자, 언더스코어 개수 등도 모두 일치해야 하므로 주의하세요.
- 예시:
  - `categories`에 `id: xray`가 있으면, 분류 규칙의 `category_id`도 반드시 `xray`여야 합니다.
  - `id: ct_abd` → `category_id: ct_abd` (O)
  - `id: ct-abd` → `category_id: ct-abd` (X, 언더스코어/하이픈 불일치)
- **ID 명명 규칙** 및 일관성에 대한 자세한 내용은 [규칙파일 작성 가이드](./1._규칙파일_작성_가이드.md#카테고리-id-명명-규칙)를 참고하세요.

#### `composed_by_subcategories` 옵션 설명

이 옵션은 카테고리가 하위 카테고리로만 구성되는지를 제어합니다:

- **`true`**: 해당 카테고리는 하위 카테고리로만 구성됨
  - **조건(`conditions`) 무시**: `conditions` 배열이 있어도 무시됨
  - **동적 구성**: 하위 카테고리들의 조건을 통해 동적으로 구성
  - 직접적인 데이터 할당 없음
  - 모든 데이터는 하위 카테고리로 분류되어야 함

- **`false` 또는 생략 (기본값)**: 해당 카테고리에 직접 데이터 할당 가능
  - **조건 평가**: `conditions` 배열의 조건들을 평가하여 분류
  - 하위 카테고리와 함께 직접적인 데이터도 포함

## 3. `conditions` 상세 설명

각 `condition` 객체는 다음 속성을 가집니다.

- `operator`: (`string`, 필수) 조건을 평가하는 데 사용될 논리 연산자입니다. 지원되는 연산자는 다음과 같습니다.
  - `contains`: `field`의 값이 `value`를 포함하는지 확인합니다.
  - `not_contains`: `field`의 값이 `value`를 포함하지 않는지 확인합니다.
  - `contains_any`: `field`의 값이 `value`(배열)에 포함된 값 중 **하나라도** 포함하는지 확인합니다.
  - `contains_all`: `field`의 값이 `value`(배열)에 있는 **모든 값이** 모두 포함되어 있는지 확인합니다.
  - `not_contains_any`: `field`의 값이 `value`(배열)의 **값 중 하나라도 포함하지 않아야** 조건을 만족합니다.
  - `not_contains_all`: `field`의 값이 `value`(배열)에 있는 **모든 값이 모두 포함되어 있지 않을 때** 조건을 만족합니다.
  - `equals`: `field`의 값이 `value`와 정확히 일치하는지 확인합니다.
  - `equals_any`: `field`의 값이 `value`(배열)에 포함된 값 중 **하나라도** 일치하는지 확인합니다.
  - `not_equals`: `field`의 값이 `value`와 정확히 일치하지 않는지 확인합니다.
  - `startsWith`: `field`의 값이 `value`로 시작하는지 확인합니다.
  - `endsWith`: `field`의 값이 `value`로 끝나는지 확인합니다.
  - `greaterThan`: `field`의 값이 `value`보다 큰지 확인합니다.
  - `lessThan`: `field`의 값이 `value`보다 작은지 확인합니다.
  - `between`: `field`의 값이 `value` (배열 `[min, max]` 형식) 범위 내에 있는지 확인합니다.
  - `regex`: `field`의 값이 `value` (정규 표현식)와 일치하는지 확인합니다.
- `field`: (`string`, 필수) 검사할 데이터 필드의 이름입니다. `column_mapping` 섹션에 정의된 `field` 중 하나여야 합니다.
  - **`age` 필드 특별 처리:** `age` 필드는 "00D 00M 00Y" 형식의 문자열 (예: "1Y 3M", "13M", "365D") 또는 순수 숫자(예: 17)를 모두 처리하며, 내부적으로는 `연도(years)` 단위의 정수로 변환되어 비교됩니다. 이 과정에서 `days`와 `months`는 `years`로 내림 처리됩니다 (예: 13M은 1년으로 처리). 따라서 `age` 필드에 조건을 적용할 때는 연도 단위의 숫자를 사용하십시오.
- `value`: (`string`, `number`, `[number, number]`, 필수) `operator`와 비교할 값입니다. `between` 연산자의 경우 `[min, max]` 형식의 숫자 배열입니다.
- `case_sensitive`: (`boolean`, 선택 사항, 기본값: `false`) 비교 시 대소문자를 구분할지 여부를 지정합니다.
  - `false` (기본값): 대소문자를 구분하지 않음 (예: "CT"와 "ct"가 같음)
  - `true`: 대소문자를 구분함 (예: "CT"와 "ct"가 다름)
  - 생략 시 자동으로 `false`로 처리됩니다.

  **사용 예시:**

  ```yaml
  # 기본값 사용 (대소문자 구분 안함)
  - operator: contains
    field: modality
    value: 'CT'
    # case_sensitive 생략 시 false로 처리

  # 명시적으로 대소문자 구분 안함
  - operator: contains
    field: modality
    value: 'CT'
    case_sensitive: false

  # 대소문자 구분함
  - operator: equals
    field: department
    value: 'ER'
    case_sensitive: true # "ER"과 "er"을 다르게 처리
    
  # field 값에 value 중 하나라도 포함되면 true
  - operator: contains_any
    field: exam_name
    value: ['CT', 'MRI', 'US']

  # field 값에 value의 모든 값이 모두 포함되면 true
  - operator: contains_all
    field: exam_name
    value: ['abdomen', 'contrast']

  # field 값에 value의 값 중 하나라도 포함되면 false (포함되지 않아야 true)
  - operator: not_contains_any
    field: department
    value: ['Internal', 'Surgery']

  # field 값에 value의 모든 값이 모두 없어야 true
  - operator: not_contains_all
    field: description
    value: ['emergency', 'pediatric']
  ```

- `regex_flags`: (`string`, 선택 사항) `regex` 연산자에 적용될 플래그 (예: `i` for case-insensitive). `regex` 연산자와 함께 사용됩니다.
- `logic`: (`string`, 선택 사항, 기본값: `AND`) 여러 하위 조건이 평가되는 방법을 정의합니다. `AND` 또는 `OR`이 될 수 있습니다. (이것은 중첩된 조건에 사용됩니다.)
- `conditions`: (`array`, 선택 사항) 중첩된 조건을 포함하는 목록입니다. `logic` 필드와 함께 사용됩니다.

## 4. 분류 우선순위

### 각 레벨의 priority 순서

분류 시스템의 각 계층(검사종류, 세부전공, 비고)에서는 `priority` 값이 낮을수록 높은 우선순위를 가집니다. 즉, 같은 레벨 내에서 `priority: 1`이 가장 먼저 평가되고, 숫자가 커질수록 나중에 평가됩니다.

`classification_rules`에서 지정한 `priority` 값은 같은레벨끼리 평가됩니다.
  예시:

  ```yaml
  - category_id: ct
    priority: 2
    conditions: ...
  - category_id: intervention
    priority: 1 # 시술이 CT보다 먼저 평가됨
    conditions: ...
  ```

  ```yaml
  - category_id: ct_ped
    parent_category_id: ct
    priority: 1 # CT 중에서 neu보다 소아여부를 먼저 평가
    conditions: ...
  - category_id: ct_neu
    parent_category_id: ct
    priority: 2
    conditions: ...
  ```

#### 우선순위 지정 시 주의사항

- `priority`가 낮은 규칙이 먼저 평가되어 해당 규칙에 일치하면 이후 규칙은 평가되지 않습니다.
- 같은 레벨에서 `priority` 값이 중복되면 예측 불가능한 분류가 발생할 수 있으므로 고유하게 지정하는 것이 좋습니다.
- 소아 등 특수 분류는 `priority: 1`로 설정하여 먼저 평가되도록 하는 것을 권장합니다.
- `priority`를 지정하지 않으면 기본값(10)이 적용됩니다.

#### `_etc` 카테고리의 동적 생성

시스템은 서브카테고리가 있는 상위 카테고리에서 모든 항목이 반드시 서브카테고리에 할당되도록 보장합니다. 이를 위해 `_etc` (기타) 카테고리가 중요한 역할을 합니다:

**동적 생성 규칙:**

- `categories`에 `_etc` 카테고리가 정의되어 있지만 `classification_rules`에 해당 규칙이 없는 경우
- 시스템이 자동으로 다음과 같은 기본 규칙을 동적으로 생성합니다:

```yaml
# 동적으로 생성되는 _etc 규칙 예시
- category_id: xray_etc
  parent_category_id: xray
  name: '기타'
  priority: 999 # 가장 낮은 우선순위
  logic: AND
  conditions: [] # 조건 없음 = 모든 데이터 받아들임
```

## 5. 중첩된 `conditions`

`conditions`는 논리 복잡성을 허용하기 위해 중첩될 수 있습니다. `logic` 속성을 사용하여 중첩된 조건 그룹이 `AND` 또는 `OR`로 연결될지 여부를 지정할 수 있습니다. 예를 들어:

```yaml
# 계층적 분류 규칙 예시

# 1단계: 검사종류 분류
- category_id: ct
  name: 'CT'
  priority: 2
  conditions:
    - operator: contains
      field: modality
      value: 'CT'
      case_sensitive: false
    - operator: not_contains
      field: modality
      value: 'PT'
      case_sensitive: false

# 1단계: 검사종류 분류 (composed_by_subcategories 예시)
- category_id: ct
  name: 'CT'
  composed_by_subcategories: true # 하위 세부전공으로만 구성
  # conditions는 무시됨

# 2단계: 세부전공 분류 (CT의 경우)
- category_id: ct_ped
  name: '소아'
  priority: 1 # 우선순위 설정 예시
  conditions:
    - operator: lessThan
      field: age
      value: 17

- category_id: ct_neu
  name: '신경두경부'
  priority: 2
  conditions:
    - logic: OR # 명시적 OR 사용 예시
      conditions:
        - operator: contains
          field: assign
          value: 'H&N'
        - operator: contains
          field: assign
          value: 'NEU'
    - operator: not_contains
      field: exam_name
      value: 'SPINE'

- category_id: ct_abd
  name: '복부'
  priority: 5
  conditions:
    - operator: contains
      field: assign
      value: 'ABD'

# 3단계: 비고 분류 (비고 레벨이 있는 세부전공의 경우)
- category_id: ct_ped_neu
  name: '신경두경부'
  priority: 1
  conditions:
    - logic: OR # 명시적 OR 사용 예시
      conditions:
        - operator: contains
          field: assign
          value: 'H&N'
        - operator: contains
          field: assign
          value: 'NEU'

- category_id: ct_ped_abd
  name: '복부'
  priority: 2
  conditions:
    - operator: contains
      field: assign
      value: 'ABD'
```

## 6. 분류 규칙 속성 참조

### 6.1. 공통 속성

모든 분류 규칙에서 사용할 수 있는 속성들:

| 속성                        | 타입    | 필수 | 설명                                              |
| --------------------------- | ------- | ---- | ------------------------------------------------- |
| `category_id`               | string  | ✓    | 대상 카테고리 ID                                  |
| `priority`                  | number  |      | 우선순위 (기본값: 10, 낮을수록 높은 우선순위)     |
| `conditions`                | array   | ✓    | 분류 조건들                                       |
| `logic`                     | string  |      | 조건 결합 논리 (기본값: AND)                      |
| `inherit_conditions_from`   | string  |      | 다른 규칙의 조건을 상속받을 규칙 ID               |
| `composed_by_subcategories` | boolean |      | 하위 카테고리로만 구성되는지 여부 (기본값: false) |

## 7. 조건 상속 기능

### 7.1. 개요

`inherit_conditions_from` 기능을 사용하면 다른 분류 규칙의 조건을 재사용할 수 있습니다. 특히 소아 분류에서 성인 세부전공의 조건을 그대로 활용할 때 매우 유용합니다.

### 7.2. 기본 원리

```yaml
classification_rules:
  # 기본 규칙 (성인 신경두경부)
  - category_id: xray_neu
    name: '신경두경부'
    priority: 10
    conditions:
      - logic: OR
        conditions:
          - operator: contains
            field: assign
            value: 'H&N'
          - operator: contains
            field: assign
            value: 'NEU'
      - operator: not_contains
        field: exam_name
        value: 'spine'

  # 소아 기본 규칙
  - category_id: xray_ped
    name: '소아'
    priority: 1
    conditions:
      - operator: lessThan
        field: age
        value: 17

  # 조건 상속을 사용한 소아 신경두경부
  - category_id: xray_ped_neu
    parent_category_id: xray_ped
    name: '신경두경부'
    inherit_conditions_from: xray_neu # 성인 신경두경부 조건 상속
    # 추가 conditions 없음 - 완전히 상속받은 조건만 사용
```


[규칙파일 작성 가이드](./1._규칙파일_작성_가이드.md)
[CSV/Excel 내보내기 가이드](./3._내보내기_설정_가이드.md)